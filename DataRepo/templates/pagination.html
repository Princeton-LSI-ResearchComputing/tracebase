{% load static %}
{% load customtags %}

{% if is_bst_paginated %}
    {{ not_exported|json_script:"not_exported" }}
    {{ warnings|json_script:"warnings" }}
    {{ filter_select_lists|json_script:"filter_select_lists" }}
    <script>
        const filterSelectOptions = {};
        let exportTypes = [];

        function getViewCookie(name, defval) {
            return getCookie('{{ cookie_prefix }}' + name, defval)
        }

        function setViewCookie(name, val) {
            return setCookie('{{ cookie_prefix }}' + name, val)
        }

        function deleteViewCookie(name) {
            return deleteCookie('{{ cookie_prefix }}' + name)
        }

        function getViewColumnCookie(column, name, defval) {
            return getViewCookie(name + '-' + column, defval)
        }

        function setViewColumnCookie(column, name, val) {
            return setViewCookie(name + '-' + column, val)
        }

        function deleteViewColumnCookie(column, name) {
            return deleteViewCookie(name + '-' + column)
        }

        function updatePage(page, limit, exportType) {
            if (typeof limit === "undefined" || (limit !== 0 && !limit)) {
                limit = getViewCookie("limit", {{ limit }});
            }
            if (typeof page === "undefined" || !page) {
                page = getViewCookie("page", 1);
            }

            url = "{% url request.resolver_match.url_name %}?page=" + page
            if (typeof limit !== "undefined" && (limit === 0 || limit)) {
                url += "&limit=" + limit;
            }
            if (typeof exportType !== "undefined" && exportType) {
                url += "&export=" + exportType;
            }

            window.location.href = url;
        }

        /**
         * Takes the export options defined in the bootstrap table and generates a drop-down list that calls the custom exportAllPages function when clicked.
         */
        function generateExportSelect() {
            let html = '<div class="btn-group"><button type="button" class="btn btn-primary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi bi-download"></i></button>\n'
            html += '    <ul class="dropdown-menu">\n'
            for (let i=0; i < globalThis.exportTypes.length; i++) {
                let val = globalThis.exportTypes[i];
                let disp;
                if (val === 'csv')
                    disp = 'CSV';
                else if (val === 'txt')
                    disp = 'TXT';
                else if (val === 'excel')
                    disp = 'MS-Excel';
                else
                    disp = val;
                html += '        <li><a class="dropdown-item" onclick="exportAllPages(' + "'" + val + "'" + ')">' + disp + '</a></li>\n';
            }
            html += '    </ul>\n';
            html += '</div>\n';
            checkBuiltinExport();
            return html
        }

        function checkBuiltinExport() {
            let tableElem = document.getElementById("{{ table_id }}");
            if (tableElem.hasAttribute('data-show-export') && $('#{{ table_id }}').data("show-export"))
                alert('ERROR: data-show-export is custom-handled, so must be false.');
        }

        function exportAllPages(format) {
            updatePage(undefined, undefined, format);
        }

        function updateVisible(visible, columnName) {
            let columnNames = getColumnNames();
            if (typeof columnName !== "undefined" && columnName) {
                if (columnNames.includes(columnName)) {
                    columnNames = [columnName];
                } else if (columnNames.length === 0) {
                    console.error("No data-field values could be found.  The table's th tags must have data-field attributes.  If they are defined, there must be a problem with the getColumnNames function.");
                    alert("Error: Unable to save your column visibility selection");
                    return
                } else {
                    console.error("updateVisible called with invalid data-field:", columnName, "The second argument must match a data-field value defined in the table's th tags.  Current data-fields:", columnNames);
                    alert("Error: Unable to save your column visibility selection");
                    return
                }
            }
            for (let i=0; i < columnNames.length; i++) {
                setViewColumnCookie(columnNames[i], 'visible', visible);
            }
        }

        function onRowsPerPageChange(numRows) {
            let oldLimit = parseInt(getViewCookie('limit', {{ limit }}));
            if (isNaN(oldLimit)) {
                oldLimit = {{ page_obj.paginator.per_page }};
            }
            let curPage = parseInt(getViewCookie('page'));
            if (isNaN(curPage)) {
                curPage = 1;
            }
            let curOffset = (curPage - 1) * oldLimit + 1;
            let closestPage = curPage;
            setViewCookie('limit', numRows);
            if (numRows !== 0) {
                closestPage = parseInt(curOffset / numRows) + 1;
                // Reset the page
                setViewCookie("page", closestPage);
            }
            updatePage();
        }

        function onPageChange(page) {
            setViewCookie('page', page)
            updatePage();
        }

        function getColumnNames() {
            let columnNames = [];
            $('#{{ table_id }}').bootstrapTable('getVisibleColumns').map(function (col) {
                columnNames.push(col.field)
            });
            $('#{{ table_id }}').bootstrapTable('getHiddenColumns').map(function (col) {
                columnNames.push(col.field)
            });
            return columnNames
        }

        function resetTable() {
            deleteViewCookie('page');
            deleteViewCookie('limit');
            deleteViewCookie('order-by');
            deleteViewCookie('order-dir');
            deleteViewCookie('search');
            columnNames = getColumnNames();
            for (i=0; i < columnNames.length; i++) {
                columnName = columnNames[i];
                deleteViewColumnCookie(columnName, 'filter');
                deleteViewColumnCookie(columnName, 'visible');
            }
            updatePage(1, {{ limit_default }});
        }

        function customButtonsFunction () {
            return {
                btnClear: {
                    'text': 'Reset Page to default settings',
                    'icon': 'bi-house',
                    'event': function btnClearTableSettings () {
                        resetTable();
                    },
                    'attributes': {
                        'title': 'Restore default sort, filter, search, column visibility, and pagination'
                    }
                },
                btnExportAll: {
                    html: generateExportSelect
                }
            }
        }

        function exportMessage() {
            if ({{ limit }} !== 0 && {{ limit }} < {{ total }}) {
                if (confirm("Download 1 page?\n\nTo retrieve all data, cancel and select 'ALL' from the rows per page select list below and try again.")) {
                    console.log("Downloading page {{ page_obj.number }}.");
                } else {
                    throw new Error("Canceling download");
                }
            }
        }

        function displayWarnings(warningsArray) {
            if (warningsArray.length > 0) {
                let warningText = "Please note the following warnings that occurred:\n\n";
                for (i=0; i < warningsArray.length; i++) {
                    num = i + 1;
                    warningText += num + ". " + warningsArray[i] + "\n"
                }
                alert(warningText);
            }
        }

        function askForPage(curpage, num_pages){
            let valid = false
            let canceled = false
            let errmsg = ""
            let newpagenum = curpage
            while (!valid) {
                var newpagestr = prompt(errmsg + "Enter a page number between 1 and " + num_pages + ":", curpage);
                if(typeof newpagestr === 'undefined' || !newpagestr){
                    canceled = true
                    valid = true
                } else {
                    newpagenum = parseInt(newpagestr);
                    if(isNaN(newpagenum)){
                        errmsg = "Error: [" + newpagestr + "] is not an integer.\n"
                    } else if(newpagenum < 1) {
                        errmsg = "Error: [" + newpagestr + "] must be greater than 0.\n"
                    } else if(newpagenum > num_pages) {
                        errmsg = "Error: [" + newpagestr + "] must be less than or equal to the number of pages: [" + num_pages + "].\n"
                    } else {
                        valid = true
                    }
                }
            }
            if (canceled || typeof newpagenum === 'undefined' || !newpagenum) {
                newpagenum = curpage
            }
            if (newpagenum !== curpage) {
                url = "?page=" + newpagenum + "&limit={{ limit }}"
                window.location.href = url
            }
        }

        document.addEventListener("DOMContentLoaded", function(){
            // Set cookies for the current page and limit that comes from the context and is sent via url params.  Everything else is saved in cookies.
            setViewCookie('page', "{{ page_obj.number }}");
            setViewCookie('limit', {{ limit }});

            const notExportedElem = document.getElementById("not_exported");
            const notExported = JSON.parse(notExportedElem.textContent);

            let filterSelectOptionsElem = document.getElementById("filter_select_lists");
            globalThis.filterSelectOptions = JSON.parse(filterSelectOptionsElem.textContent);

            globalThis.exportTypes = JSON.parse($('#{{ table_id }}').data("export-types").replace(/'/g, '"'));

            const warningsElem = document.getElementById("warnings");
            const warnings = JSON.parse(warningsElem.textContent);
            displayWarnings(warnings);

            var loading = true;

            $('#{{ table_id }}').bootstrapTable({
                onSort: function (orderBy, orderDir) {
                    setViewCookie('order-by', orderBy);
                    setViewCookie('order-dir', orderDir);
                    // BST sort and server side sort sometimes sort differently (c.i.p. imported_timestamp), so we will always let the sort hit the server to be on the safe side.
                    updatePage(1);
                },
                onSearch: function (searchTerm) {
                    if (!loading) {
                        // NOTE: Turns out that on page load, a global search event is triggered, so we check to see if anything changed before triggering a page update.
                        let oldTerm = getViewCookie('search');
                        let oldTermDefined = typeof oldTerm === "undefined" || !oldTerm;
                        let newTermDefined = typeof searchTerm === "undefined" || !searchTerm;
                        if (oldTermDefined !== newTermDefined || (oldTermDefined && newTermDefined && oldTerm !== searchTerm)) {
                            setViewCookie('search', searchTerm);
                            // No need to hit the server if we're displaying all results. Just let BST do it.
                            if ({{ limit }} > 0 && {{ limit }} < {{ total }} || {{ total }} < {{ raw_total }}) {
                                updatePage(1);
                            }
                        }
                    }
                },
                onColumnSearch: function (columnName, searchTerm) {
                    if (!loading) {
                        // NOTE: Turns out that on page load, a column search event is triggered, so we check to see if anything changed before triggering a page update.
                        let oldTerm = getViewColumnCookie(columnName, 'filter');
                        let oldTermDefined = typeof oldTerm !== "undefined" && oldTerm;
                        let newTermDefined = typeof searchTerm !== "undefined" && searchTerm;
                        if (oldTermDefined !== newTermDefined || (oldTermDefined && newTermDefined && oldTerm !== searchTerm)) {
                            setViewColumnCookie(columnName, 'filter', searchTerm);
                            // No need to hit the server if we're displaying all results. Just let BST do it.
                            if (({{ limit }} > 0 && {{ limit }} < {{ total }}) || {{ total }} < {{ raw_total }}) {
                                updatePage(1);
                            }
                        }
                    }
                },
                onColumnSwitch: function (columnName, visible) {
                    updateVisible(visible, columnName);
                },
                onColumnSwitchAll: function (visible) {
                    updateVisible(visible);
                },
                onExportStarted: function (event) {
                    exportMessage();
                },
                onLoadError: function (status, jqXHR) {
                    console.error("BootstrapTable Error.  Status: '" + status + "' Data:", jqXHR);
                },
                exportOptions: {
                    ignoreColumn: notExported,
                },
            });

            // Add click listeners on the rows-per-page-option select list items.  See DataRepo.widgets.ListViewRowsPerPageSelectWidget.
            let rowsPerPageOptionElems = document.getElementsByName("rows-per-page-option");
            for (let i = 0; i < rowsPerPageOptionElems.length; i++) {
                rowsPerPageOptionElems[i].addEventListener("click", function (event) {
                    onRowsPerPageChange($(this).data("value"));
                })
            }

            setTimeout(function () {loading = false}, 2000);
        });
    </script>
    <!-- Model list view built-in Pagination -->
    <!-- Allow user to reduce the number of rows per page and see the number of results -->
    {% if total > 0 %}
        <br>
        <div style="float: left;">
            <!-- Generate the "Showing N to M of T rows," message -->
            {% if page_obj.number|intmultiply:page_obj.paginator.per_page > total %}
                <!-- Different calculations for the last page -->
                {% define total as last_row %}
            {% else %}
                {% define page_obj.number|intmultiply:page_obj.paginator.per_page as last_row %}
            {% endif %}
            Showing {{ page_obj.number|add:-1|intmultiply:page_obj.paginator.per_page|add:1 }} to {{ last_row }} of <span title="Unfiltered: {{ raw_total }}">{{ total }}</span> rows,

            <!-- Generate the rows per page select list -->
            {% define '5 10 15 20 25 50 100 200 500 1000 0' as per_page_opts_str %}
            {% filter_page_size_list per_page_opts_str.split total page_obj.paginator.per_page as per_page_opts %}
            {% if page_obj.paginator.per_page >= total %}
                {% get_rows_per_page_select_list per_page_opts "paginate_by" 0 %}
            {% else %}
                {% get_rows_per_page_select_list per_page_opts "paginate_by" page_obj.paginator.per_page %}
            {% endif %}
            rows per page
        </div>
    {% endif %}
    <!-- Actually paginate when there's more than 1 page of results -->
    {% if page_obj.has_other_pages %}
        <div style="float: right;" class="btn-group" role="group">
            {% with 3 as flank %}  <!-- flank = the number of pages to link to the left and right of the current page -->
                <!-- Generate the "<"/previous button -->
                {% if page_obj.has_previous %}
                    <a href="?page={{ page_obj.previous_page_number }}" class="btn btn-outline-primary">&laquo;</a>
                {% endif %}

                <!-- Generate the "1" button if the current page is more than flank-size away and the left side ellipsis button if there are pages between 1 and the pages close to the current page -->
                {% if 1 <= flank|multiply:-1|add:page_obj.number %}
                    <a href="?page=1&limit={{ limit }}" class="btn btn-outline-primary">
                        1
                    </a>
                    {% if 1 <= flank|add:1|multiply:-1|add:page_obj.number %}
                        <button class="btn btn-outline-primary" onclick="askForPage({{ page_obj.number }}, {{ page_obj.paginator.num_pages }})">
                            &hellip;
                        </button>
                    {% endif %}
                {% endif %}

                <!-- Generate pagination buttons for pages close to the current page.  This includes a "selected" button for the current page. -->
                {% for page_number in page_obj.paginator.page_range %}
                    {% if page_obj.number == page_number %}
                        <button class="btn btn-outline-primary active">
                            <span>{{ page_number }} <span class="sr-only">(current)</span></span>
                        </button>
                    {% elif page_number > flank|multiply:-1|add:page_obj.number and page_number < page_obj.number|add:flank %}
                        <a href="?page={{ page_number }}&limit={{ limit }}" class="btn btn-outline-primary">
                            {{ page_number }}
                        </a>
                    {% endif %}
                {% endfor %}

                <!-- Generate the right side ellipsis button if there are pages between the pages close to the current page and the last page, and a button for the last page if the current page is more than flank-size away -->
                {% if page_obj.paginator.num_pages >= page_obj.number|add:flank %}
                    {% if page_obj.paginator.num_pages >= page_obj.number|add:flank|add:-1 %}
                        <button class="btn btn-outline-primary" onclick="askForPage({{ page_obj.number }}, {{ page_obj.paginator.num_pages }})">
                            &hellip;
                        </button>
                    {% endif %}
                    <a href="?page={{ page_obj.paginator.num_pages }}&limit={{ limit }}" class="btn btn-outline-primary">
                        {{ page_obj.paginator.num_pages }}
                    </a>
                {% endif %}

                <!-- Generate the ">"/next button -->
                {% if page_obj.has_next %}
                    <a href="?page={{ page_obj.next_page_number }}&limit={{ limit }}" class="btn btn-outline-primary">&raquo;</a>
                {% endif %}
            {% endwith %}
        </div>
    {% endif %}
    <br><br>
{% elif pager %}
    {% comment %} Advanced Search Pagination (assumed, though the "pager" object could be used for other pagination as well) {% endcomment %}
    <script>
        document.addEventListener("DOMContentLoaded", function(){

            var myform = document.getElementById("{{ pager.form_id }}")
            var rowselem = document.getElementById("{{ pager.rows_input_id }}")
            if (typeof rowselem !== 'undefined' && rowselem) {
                rowselem.addEventListener("change", function (event) {
                    set_template_cookie("{{ pager.rows_per_page_field }}", event.target.value)
                    setPage(1)
                    submitForm()
                })
            }
            // Submits the form with a show_stats true value after the message about it possibly taking a few seconds appears...
            var statselem = document.getElementById("{{ pager.other_field_ids.show_stats }}")
            {% if not stats.populated %}
                $('#resultstats').on('shown.bs.collapse', function (e) {
                    statselem.value = true
                    submitForm()
                })
            {% else %}
                $('#resultstats').on('show.bs.collapse', function () {
                    statselem.value = true
                })
                $('#resultstats').on('hide.bs.collapse', function () {
                    statselem.value = false
                })
            {% endif %}

            updateColumnSortControls()
        })

        function updateColumnSortControls() {
            // Add sort controls to every sortable column header (div around th contents with class 'sortable')

            // The column ID must match the database field path contained in the pager's order_by member variable, e.g. "peak_group__msrun_sample__sample__animal__name"
            sorted_column_id = "{{ pager.order_by }}"
            sorted_dir = {% if pager.order_dir is None %}"undefined"{% else %}"{{ pager.order_dir }}"{% endif %}

            // Check that the sorted column ID is valid
            sorted_column_elem = document.getElementById(sorted_column_id)
            if (typeof sorted_column_elem === "undefined" || !sorted_column_elem) {
                if (sorted_column_id !== "" && sorted_column_id !== "None") {
                    alert("ERROR: Could not find sortable div element with the ID " + sorted_column_id + ".  Make sure a div element containing the class 'sortable' and the given ID exists in the template.  Abandonning sorted column control settings.")
                }
                // Else: No explicit sort exists, all columns should be "both"
                console.log("Sort column not set")
            }

            $('.sortable').each(function() {
                var elem_id = this.id
                if (elem_id === sorted_column_id) {
                    // I think bootstrap table's javascript is adding "both" on page load...
                    this.classList.remove("both")
                    if (sorted_dir === "undefined" || !sorted_dir || sorted_dir === "asc") {
                        this.classList.add("asc")
                    } else if (sorted_dir === "desc") {
                        this.classList.add("desc")
                    } else {
                        alert("Invalid order by direction [" + sorted_dir + "].  Must be None, 'asc', or 'desc'.  Abandonning sorted column control settings.")
                    }
                } else {
                    this.classList.add('both')
                }
            })
        }

        function sortColumn(elem) {
            isBoth = $(elem).hasClass("both")
            isAsc = $(elem).hasClass("asc")
            isDesc = $(elem).hasClass("desc")

            sort_col_id = elem.id

            if (isBoth) {
                setPage(1)
                setOrderBy(sort_col_id)
                setOrderDir("asc")
            } else if (isAsc) {
                setOrderBy(sort_col_id)
                setOrderDir("desc")
            } else if (isDesc){
                setOrderBy(sort_col_id)
                setOrderDir("asc")
            } else {
                // This should not happen
                alert("ERROR: sortColumn called from an element (ID: " + sort_col_id + ") that is not set up for sorting.  Make sure sortColumn is being called from an element containing the sortable class.")
                return
            }

            submitForm()
        }

        function toggleStats(obj) {
            {% if not stats.populated %}
                var statselem = document.getElementById("{{ pager.other_field_ids.show_stats }}")
                if (statselem !== "undefined" && statselem) {
                    $('#resultstats').collapse("show")
                } else {
                    console.error("Unable to retrieve the show_stats button.")
                }
            {% else %}
                console.log("Value in stats.populated: " + "{{ stats.populated }}")
            {% endif %}
        }

        function submitForm() {
            var myform = document.getElementById("{{ pager.form_id }}")
            myform.submit();
        }

        function setOrderBy(field_path) {
            setPageFormValue("{{ pager.orderby_input_id }}", field_path)
        }

        function setOrderDir(dir) {
            setPageFormValue("{{ pager.orderdir_input_id }}", dir)
        }

        function setPage(pagenum){
            setPageFormValue("{{ pager.page_input_id }}", pagenum)
        }

        function promptForPage(curpage, num_pages){
            valid = false
            canceled = false
            errmsg = ""
            while(!valid){
                var newpagestr = prompt(errmsg + "Enter a page number between 1 and " + num_pages + ":", curpage);
                if(typeof newpagestr === 'undefined' || !newpagestr){
                    canceled = true
                    valid = true
                } else {
                    var newpagenum = parseInt(newpagestr);
                    if(isNaN(newpagenum)){
                        errmsg = "Error: [" + newpagestr + "] is not an integer.\n"
                    } else if(newpagenum < 1) {
                        errmsg = "Error: [" + newpagestr + "] must be greater than 0.\n"
                    } else if(newpagenum > num_pages) {
                        errmsg = "Error: [" + newpagestr + "] must be less than or equal to the number of pages: [" + num_pages + "].\n"
                    } else {
                        valid = true
                    }
                }
            }
            if(!canceled){
                setPage(newpagenum)
                submitForm()
            }
        }

        function setPageFormValue(elem_id, val) {
            var input_elem = document.getElementById(elem_id)
            if (typeof input_elem !== 'undefined' && input_elem) {
                input_elem.value = val;
            } else {
                alert("Could not find page form input element: " + elem_id + ".  Make sure the input element's ID is set to this value.")
            }
        }

        function restoreDefaults() {
            // I wanted to have this inside display.html, but since reloading does a GET and not a POST, the current page needs to be POSTed, so it made sense to put it here for the form POST of the current page
            var hidarray = $("#advsrchres").bootstrapTable('getHiddenColumns')
            for (const item of hidarray) {
                set_template_cookie(item["field"] + "-data-visible", "__default__")
            }
            var visarray = $("#advsrchres").bootstrapTable('getVisibleColumns')
            for (const item of visarray) {
                set_template_cookie(item["field"] + "-data-visible", "__default__")
            }
            var myform = document.getElementById("{{ pager.form_id }}")
            myform.submit();
        }
    </script>

    {% comment %} We need at least a hidden form to support server side sorting {% endcomment %}
    <div class="fixed-table-pagination" style="{% if pager.tot|gt:pager.min_rows_per_page %}padding-top: 10px;{% else %}display:none;{% endif %}">
        <form action="{{ pager.action }}" id="{{ pager.form_id }}" method="POST">
            {% csrf_token %}
            {{ pager.page_form.qryjson }}
            {{ pager.page_form.order_by }}
            {{ pager.page_form.order_direction }}
            {{ pager.page_form.page }}
            {{ pager.page_form.paging }}
            {{ pager.page_form.show_stats }}
            {{ pager.page_form.stats }}
            <div style="float: left;">
                Showing {{ pager.start }} to {{ pager.end }} of {{ pager.tot }} rows, {{ pager.page_form.rows }} rows per page
            </div>
            {% if pager.tot|gt:pager.rows %}
                <div style="float: right;">
                    <nav aria-label="Page navigation">
                        <ul class="pagination">
                            {% for pg in pager.pages %}
                                {% if pg.navigable %}
                                    <li class="page-item">
                                        <button type="submit" class="page-link" id="advanced-page-submit" onclick="setPage({{ pg.val }})" name="{{ pager.submit_name }}">{{ pg.name }}</button>
                                    </li>
                                {% else %}
                                    {% if pg.val == pager.page %}
                                        <li class="page-item active">
                                            <div class="page-link">{{ pg.name }} <span class="sr-only">(current)</span></div>
                                        </li>
                                    {% elif pg.name == "..." %}
                                        <li class="page-item" onclick="promptForPage({{ pager.page }}, {{ pager.num_pages }})">
                                            <a class="page-link" href="#">{{ pg.name }}</a>
                                        </li>
                                    {% else %}
                                        <li class="page-item disabled">
                                            <a class="page-link" href="#">{{ pg.name }}</a>
                                        </li>
                                    {% endif %}
                                {% endif %}
                            {% endfor %}
                        </ul>
                    </nav>
                </div>
            {% endif %}
        </form>
    </div>
{% endif %}
